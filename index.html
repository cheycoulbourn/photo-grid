<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.13/cropper.min.css">
    <!-- Previous styles remain exactly the same -->
    <style>
        /* All previous styles remain exactly the same */
        /* ... */
        .debug-panel {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 1000;
            max-width: 300px;
            display: none;
        }
    </style>
</head>
<body>
    <div class="status-message" id="statusMessage"></div>
    <div class="debug-panel" id="debugPanel"></div>
    <div class="grid-container"></div>
    
    <!-- Modal remains exactly the same -->
    <div class="modal" id="cropModal">
        <!-- ... modal content remains the same ... -->
    </div>

    <script>
        let cropper = null;
        let activeGridItem = null;
        const STORAGE_KEY = 'instagram_grid_images_v1'; // Unique storage key

        // Debug function
        function debug(message) {
            const debugPanel = document.getElementById('debugPanel');
            const timestamp = new Date().toLocaleTimeString();
            debugPanel.innerHTML += `${timestamp}: ${message}<br>`;
            debugPanel.style.display = 'block';
            console.log(`${timestamp}: ${message}`);
        }

        // Function to check if localStorage is available
        function isStorageAvailable() {
            try {
                const test = '__storage_test__';
                localStorage.setItem(test, test);
                localStorage.removeItem(test);
                return true;
            } catch(e) {
                debug('localStorage not available: ' + e.message);
                return false;
            }
        }

        // Function to save images to localStorage with error handling
        function saveImages() {
            try {
                if (!isStorageAvailable()) {
                    showStatus('Storage not available', 3000);
                    return;
                }

                const images = {};
                let totalSize = 0;
                
                document.querySelectorAll('.grid-item img').forEach(img => {
                    const index = img.dataset.index;
                    if (img.src && img.style.display !== 'none') {
                        images[index] = img.src;
                        totalSize += img.src.length;
                    }
                });

                const imagesJSON = JSON.stringify(images);
                debug(`Attempting to save ${Object.keys(images).length} images (${Math.round(totalSize/1024)}KB)`);
                
                try {
                    localStorage.setItem(STORAGE_KEY, imagesJSON);
                    debug('Images saved successfully');
                    showStatus('Changes saved');
                } catch (e) {
                    debug('Error saving to localStorage: ' + e.message);
                    showStatus('Error saving changes - storage might be full', 3000);
                    
                    // If storage is full, try to save compressed versions
                    if (e.name === 'QuotaExceededError') {
                        compressAndSave(images);
                    }
                }
            } catch (e) {
                debug('Error in saveImages: ' + e.message);
                showStatus('Error saving changes', 3000);
            }
        }

        // Function to compress images if storage is full
        function compressAndSave(images) {
            try {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const maxDimension = 800; // Max width/height for compressed images
                
                Object.entries(images).forEach(([index, src]) => {
                    const img = new Image();
                    img.onload = () => {
                        let width = img.width;
                        let height = img.height;
                        
                        if (width > maxDimension || height > maxDimension) {
                            if (width > height) {
                                height *= maxDimension / width;
                                width = maxDimension;
                            } else {
                                width *= maxDimension / height;
                                height = maxDimension;
                            }
                        }
                        
                        canvas.width = width;
                        canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);
                        images[index] = canvas.toDataURL('image/jpeg', 0.7);
                    };
                    img.src = src;
                });

                // Try saving again after compression
                setTimeout(() => {
                    try {
                        localStorage.setItem(STORAGE_KEY, JSON.stringify(images));
                        debug('Compressed images saved successfully');
                        showStatus('Changes saved (compressed)');
                    } catch (e) {
                        debug('Error saving compressed images: ' + e.message);
                        showStatus('Unable to save changes', 3000);
                    }
                }, 500);
            } catch (e) {
                debug('Error in compressAndSave: ' + e.message);
            }
        }

        // Function to load images from localStorage with error handling
        function loadImages() {
            try {
                if (!isStorageAvailable()) {
                    debug('Storage not available for loading');
                    return;
                }

                const savedImages = localStorage.getItem(STORAGE_KEY);
                if (!savedImages) {
                    debug('No saved images found');
                    return;
                }

                const images = JSON.parse(savedImages);
                debug(`Loading ${Object.keys(images).length} saved images`);

                Object.entries(images).forEach(([index, src]) => {
                    const img = document.querySelector(`img[data-index="${index}"]`);
                    if (img) {
                        img.src = src;
                        img.style.display = 'block';
                        img.closest('.grid-item').querySelector('.upload-overlay').style.display = 'none';
                        debug(`Loaded image for index ${index}`);
                    }
                });

                showStatus('Images restored', 2000);
            } catch (e) {
                debug('Error in loadImages: ' + e.message);
                showStatus('Error loading saved images', 3000);
            }
        }

        function showStatus(message, duration = 2000) {
            const status = document.getElementById('statusMessage');
            status.textContent = message;
            status.style.display = 'block';
            setTimeout(() => {
                status.style.display = 'none';
            }, duration);
        }

        // Rest of the functions remain the same, but with save calls added
        function setupGridItem(gridItem) {
            const fileInput = gridItem.querySelector('.file-input');
            const uploadOverlay = gridItem.querySelector('.upload-overlay');
            const img = gridItem.querySelector('img');
            const cropButton = gridItem.querySelector('.crop-button');
            const removeButton = gridItem.querySelector('.remove-button');

            uploadOverlay.addEventListener('click', () => fileInput.click());

            fileInput.addEventListener('change', (e) => {
                if (e.target.files && e.target.files[0]) {
                    const file = e.target.files[0];
                    const reader = new FileReader();

                    reader.onload = (e) => {
                        img.src = e.target.result;
                        img.style.display = 'block';
                        uploadOverlay.style.display = 'none';
                        showStatus('Image uploaded');
                        saveImages(); // Save after upload
                    };

                    reader.readAsDataURL(file);
                }
            });

            cropButton.addEventListener('click', () => {
                activeGridItem = gridItem;
                const modalImg = document.getElementById('cropImage');
                modalImg.src = img.src;
                document.getElementById('cropModal').style.display = 'block';
                
                if (cropper) {
                    cropper.destroy();
                }
                
                cropper = new Cropper(modalImg, {
                    aspectRatio: 1,
                    viewMode: 1,
                    autoCropArea: 1,
                });
            });

            removeButton.addEventListener('click', () => {
                img.src = '';
                img.style.display = 'none';
                uploadOverlay.style.display = 'flex';
                fileInput.value = '';
                showStatus('Image removed');
                saveImages(); // Save after removal
            });
        }

        function closeModal() {
            document.getElementById('cropModal').style.display = 'none';
            if (cropper) {
                cropper.destroy();
                cropper = null;
            }
        }

        function cropImage() {
            if (!cropper || !activeGridItem) return;
            
            const croppedCanvas = cropper.getCroppedCanvas();
            const img = activeGridItem.querySelector('img');
            img.src = croppedCanvas.toDataURL();
            saveImages(); // Save after cropping
            
            closeModal();
            showStatus('Image cropped');
        }

        function createGridItems() {
            const container = document.querySelector('.grid-container');
            for (let i = 1; i <= 9; i++) {
                const gridItem = document.createElement('div');
                gridItem.className = 'grid-item';
                gridItem.innerHTML = `
                    <div class="image-container">
                        <img style="display: none;" alt="Image ${i}" data-index="${i-1}">
                        <div class="upload-overlay">
                            <svg class="upload-icon" viewBox="0 0 24 24">
                                <path d="M12 5v14M5 12h14"/>
                            </svg>
                            <div class="upload-text">Add Image</div>
                        </div>
                        <div class="button-container">
                            <button class="icon-button crop-button" title="Crop">✂</button>
                            <button class="icon-button remove-button">×</button>
                        </div>
                    </div>
                    <input type="file" class="file-input" accept="image/*">
                `;
                
                setupGridItem(gridItem);
                container.appendChild(gridItem);
            }
            
            // Load saved images after creating grid items
            loadImages();
        }

        document.addEventListener('DOMContentLoaded', () => {
            createGridItems();
            debug('Grid initialized');
        });
    </script>
</body>
</html>
